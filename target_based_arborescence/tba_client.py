from mpls_fwd_gen import MPLS_Client

class TargetBasedArborescence(MPLS_Client):
    def __init__(self):
        pass

    # Abstract functions to be implemented by each client subclass.
    def LFIB_compute_entry(self, fec, single=False):
        # Each client must provide an generator to compute routing entries given the fec.
        # optional parameter "single" forces the function to return just one routing entry.
        # returns tuple (label, routing_entry)
        # routing entries have format:
        #  routing_entry = { "out": next_hop_iface, "ops": [{"pop":"" | "push": remote_label | "swap": remote_label}], "weight": cost  }
        # A few rules regarding the ops:
        #
        # Rule 1:          NOp := [{"push":x}, {"pop":""}]  # should never appear in an entry.
        # Rule 2: {"swap": x } := [{"pop":""}, {"push":x}]  # can be analized with just 2 operations.
        # Corollary 1: All ops can be written with just pop and push operations
        # Corollary 2: All ops must have a form like:  [{"pop":""}^n, prod_{i=1}^{m} {"push": x_i}]
        #              which in turn can have at most one swap operation at the deepest inspected stack
        #              level, so (if m > 1 and n>1):
        #                 [{"pop":""}^{n-1}, {"swap": x_1} ,prod_{i=2}^{m} {"push": x_i}]
        pass

    def LFIB_refine(self, label):
        # Some process might require a refinement of the LFIB.
        pass

    def known_resources(self):
        # Returns a generator to iterate over all resources managed by the client.
        # Each client must provide an implementation.
        pass

    def self_sourced(self, FEC):
        # Returns True if the FEC is sourced or generated by this process.
        pass
